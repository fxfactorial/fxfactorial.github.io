<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>hyegar.com - All posts</title>
        <link>http://hyegar.com</link>
        <description><![CDATA[Personal blog of Edgar Aroutiounian]]></description>
        <atom:link href="http://hyegar.com/atom.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 08 Jan 2017 00:00:00 UT</lastBuildDate>
        <item>
    <title>variants in C++14 without boost</title>
    <link>http://hyegar.com/2017/01/08/variants-in-cpp/index.html</link>
    <description><![CDATA[<h1 id="variants-in-their-native-land">Variants in their native land</h1>
<p>One of the best parts of functional programming are <code>Algebraic Data Types</code>, also known as <code>Sum</code> types, also known as <code>variants</code>. They help you make more type safe programs, self-documenting code.</p>
<p>Here are some examples in <code>OCaml</code></p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> &#39;a <span class="dt">option</span> = <span class="dt">Some</span> <span class="kw">of</span> &#39;a | <span class="dt">None</span></code></pre></div>
<p>This is the famous option type of functional programming. A fun thing about option is that its also a Monad, so <code>&gt;&gt;=</code> aka <code>bind</code> is easily defined as:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> ( &gt;&gt;= ) x f = <span class="kw">match</span> x <span class="kw">with</span> <span class="dt">Some</span> h -&gt; f h | _ -&gt; <span class="dt">None</span></code></pre></div>
<p>Another example recently added to the OCaml standard library is the result type.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> (&#39;success, &#39;failure) result = Ok <span class="kw">of</span> &#39;success | Error <span class="kw">of</span> &#39;failure</code></pre></div>
<p>The things prefixed with <code>'</code> are called type variables, they let you write generic code from the getgo. We only need one for <code>option</code> but we need two different ones for result so that the type of the <code>Ok</code> variant need not be the same as the type of the <code>Error</code> variant.</p>
<p>Once you get an <code>result</code> value, you can pattern match on it:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> process_result = <span class="kw">function</span> 
  | Ok r -&gt; <span class="co">(* Do something with r *)</span>
  | Error reason -&gt; <span class="co">(* Do something with the error *)</span></code></pre></div>
<h1 id="variants-in-c">variants in C++</h1>
<p>In <code>C++</code> variants are not first class citizens of the language, so they need to be provided by a library. In modern <code>C++</code> our options are <code>C++17</code>’s <code>std::variant</code>, <code>boost::variant</code> or someone’s own rolled version.</p>
<p>I don’t want the <code>boost</code> dependency and I can’t use <code>C++17</code> so I looked for a library implementation. I found one by <a href="https://github.com/mapbox/variant">mapbox</a> and it fit my usecase perfectly; its a header only template library and I like the API provided. Here’s my implementation of <code>option</code> using the <code>mapbox</code> variant library.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Let&#39;s assume this file is named optional.hpp</span>
<span class="pp">#pragma once</span>

<span class="pp">#include </span><span class="im">&lt;mapbox/variant.hpp&gt;</span>

<span class="kw">namespace</span> optional {
  <span class="kw">struct</span> None { };
  <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
  <span class="kw">struct</span> Some { T payload; };

  <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
  <span class="kw">struct</span> Optional : mapbox::util::variant&lt;None, Some&lt;T&gt;&gt; {
    <span class="kw">using</span> Base = mapbox::util::variant&lt;None, Some&lt;T&gt;&gt;;
    <span class="kw">using</span> Base::Base;
  };

  <span class="co">// These two are helper functions, like std::make_unique, etc.</span>
  <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
  <span class="kw">auto</span> some(T x)  { <span class="cf">return</span> Optional&lt;T&gt;{Some&lt;T&gt;{x}}; }

  <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
  <span class="kw">auto</span> none(<span class="dt">void</span>) { <span class="cf">return</span> Optional&lt;T&gt;{None{}}; }

}</code></pre></div>
<p>And here’s an example usage:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Let&#39;s assume this file is named main.cpp</span>
<span class="pp">#include </span><span class="im">&lt;string&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>

<span class="pp">#include </span><span class="im">&quot;optional.hpp&quot;</span>

<span class="co">// This lets just make std::string just by adding a suffix of &#39;s&#39;</span>
<span class="co">// to things that otherwise look like char *</span>
<span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals<span class="bu">::</span>string_literals;

<span class="co">// Pretend that this is something that could fail.</span>
<span class="kw">auto</span> file_contents(<span class="dt">void</span>) {
  <span class="cf">return</span> optional::some(<span class="st">&quot;some file contents&quot;</span>s);
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
  file_contents()
    .match(
  	   [](optional::None) {
  	     <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Check if file existed</span><span class="sc">\n</span><span class="st">&quot;</span>;
  	   },
  	   [](<span class="kw">auto</span> some) {
  	     <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;File contents: &quot;</span> &lt;&lt; some.payload;
  	   });
}</code></pre></div>
<p>and you can easily compile it with, assuming that you added mapbox/variant.hpp to your compiler’s include search path…</p>
<pre class="shell"><code>$ clang++ -std=c++14 main.cpp</code></pre>
<p>Happy coding.</p>]]></description>
    <pubDate>Sun, 08 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://hyegar.com/2017/01/08/variants-in-cpp/index.html</guid>
    <dc:creator>Edgar Aroutiounian</dc:creator>
</item>
<item>
    <title>node's async, await, Promises.</title>
    <link>http://hyegar.com/2016/12/23/async-promises-node/index.html</link>
    <description><![CDATA[<p>While studying for interviews I’m talking breaks by working on <a href="https://github.com/fxfactorial/silicondzor">silicondzor.com</a></p>
<p>This is giving me some real web dev experience and I’m using the latest and greatest features of <code>JavaScript</code> and <code>node</code>.</p>
<p>One thing that I’m really liking in modern <code>JavaScript</code> is the <code>async</code> story, it reminds me a lot of <code>OCaml</code> and both are somewhat converging, i.e <code>ES6</code>’s introduction of Promises which are basically <code>'a Lwt.t</code>, and Lwt renaming <code>Lwt.t</code> into Promises in <code>2.7.0</code>.</p>
<p>Here’s like my conceptual cheatsheet about using <code>Promises</code> from scratch, converting an callback API into a <code>Promises</code> API and then taking it to the next step with <code>async</code>, <code>await</code>.</p>
<h1 id="basic-callback-apis">Basic callback APIs</h1>
<p><code>node</code> uses an event based programming paradigm and this is reflected in basically all server side code, ie the trailing callback argument to asynchronously call once the task completes.</p>
<p>Let’s simulate it with this function</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Plain CB based API</span>
<span class="kw">const</span> test_func <span class="op">=</span> (item<span class="op">,</span> cb) <span class="op">=&gt;</span> <span class="op">{</span>
  <span class="at">setTimeout</span>(() <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="cf">if</span> (item <span class="op">&lt;</span> <span class="dv">5</span>) <span class="at">cb</span>(<span class="kw">null</span><span class="op">,</span> <span class="st">&#39;Success&#39;</span>)<span class="op">;</span>
    <span class="cf">else</span> <span class="at">cb</span>(<span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;Oops&#39;</span>)<span class="op">,</span> <span class="kw">null</span>)<span class="op">;</span>
  <span class="op">},</span> <span class="dv">3000</span>)<span class="op">;</span>
<span class="op">};</span>

<span class="at">test_func</span>(<span class="dv">3</span><span class="op">,</span> (err<span class="op">,</span> success) <span class="op">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(success))<span class="op">;</span></code></pre></div>
<p>This models typical <code>node</code> code, the callback being called <code>three</code> seconds after execution of <code>test_func</code></p>
<p>This seems pretty fine for this example but once you have logic that is dependent on the success of one callback API after another then you start to have a difficult to reason about triangle of callbacks on the screen.</p>
<h1 id="promises">Promises</h1>
<p><code>ES6</code> introduces <code>Promises</code> and these are quite convienent, think of a Promise as being a box which will have a value in it sometime later.</p>
<p>We can turn any callback based API into a Promises based one.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Promises based</span>
<span class="kw">const</span> test_func_promise <span class="op">=</span> item <span class="op">=&gt;</span> <span class="op">{</span>
  <span class="cf">return</span> <span class="kw">new</span> <span class="at">Promise</span>((accept<span class="op">,</span> reject) <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="at">test_func</span>(item<span class="op">,</span> (err<span class="op">,</span> success) <span class="op">=&gt;</span> <span class="op">{</span>
      <span class="cf">if</span> (err) <span class="at">reject</span>(err)<span class="op">;</span>
      <span class="cf">else</span> <span class="at">accept</span>(success)<span class="op">;</span>
    <span class="op">}</span>)<span class="op">;</span>
  <span class="op">}</span>)<span class="op">;</span>
<span class="op">};</span>

<span class="at">test_func_promise</span>(<span class="dv">2</span>)
.<span class="at">then</span>(item <span class="op">=&gt;</span> <span class="op">{</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Sucess!!&#39;</span><span class="op">,</span> item)<span class="op">;</span> <span class="op">}</span>)
.<span class="at">catch</span>(err <span class="op">=&gt;</span> <span class="va">console</span>.<span class="at">error</span>(err))<span class="op">;</span></code></pre></div>
<p>When you create a new <code>Promise</code> you need to provide it with two function, one to be called when there’s a success and when the Promise should fail. Hence when calling <code>test_func_promise</code> returns a Promise, not the value <code>'Success'</code>. Also if you use the plain Promises approach be sure to include a <code>.catch</code> call.</p>
<p>This is nicer than the original callback API approach, but now all your success or failure logic and everything following that effectively has to be all in either <code>.then</code> or <code>.catch</code> and that’s a bit awkward still.</p>
<h1 id="asyncawait">async/await</h1>
<p><code>ES7</code> introduced <code>async</code>, <code>await</code> where I basically think of the latter as <code>&gt;&gt;=</code> and <code>async</code> as sort of like <code>&gt;|=</code>. With <code>async</code>, <code>await</code> we can call <code>Promises</code> based code as if it was synchronous code.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">const</span> test_func_async_example <span class="op">=</span> <span class="at">async</span> (item) <span class="op">=&gt;</span> <span class="op">{</span>
  <span class="cf">try</span> <span class="op">{</span>
    <span class="kw">const</span> result <span class="op">=</span> await <span class="at">test_func_promise</span>(item)<span class="op">;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Yay: </span><span class="sc">${</span>result<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span>
  <span class="op">}</span> <span class="cf">catch</span>(e) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">error</span>(<span class="vs">`Messed up: </span><span class="sc">${</span>e<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span>
  <span class="op">}</span>
<span class="op">};</span>

<span class="at">test_func_async_example</span>(<span class="dv">6</span>)<span class="op">;</span>
<span class="at">test_func_async_example</span>(<span class="dv">3</span>)<span class="op">;</span></code></pre></div>
<p>First notice how whatever function we use <code>await</code> inside of, we need to tag that function with <code>async</code> and now this function returns a <code>Promise</code></p>
<p>Now when we call <code>test_func_promises</code> with <code>await</code> prefixed, then we get the value that the <code>Promise</code> resolved. Also whatever the <code>reject</code> condition of the <code>Promise</code> was then becomes the exception of the <code>catch</code> following the <code>await</code> usage.</p>
<h1 id="summary">Summary</h1>
<p><code>async</code>, <code>await</code> are very powerful features of <code>ES7</code>, <code>Promises</code> are from <code>ES6</code>. Not every <code>JavaScript</code> engine supports <code>ES7</code> so you’ll have to use <code>babel</code> to compile your <code>async</code>, <code>await</code> to runnable code; basically turns the <code>async</code>, <code>await</code> to generators (also an amazing topic).</p>
<p>On newer versions of node, I’m using <code>v7.3.0</code>, you can turn on features from the future with command line arguments. Check all of them with:</p>
<pre><code>$ node --v8-options | less</code></pre>
<p>I’m turning on native <code>async</code>, <code>await</code> with <code>--harmony_async_await</code>, so my final invocation is:</p>
<pre><code>$ node --harmony_async_await test.js</code></pre>
<p>You can get all the code as one script <a href="https://gist.github.com/fxfactorial/60edd7c3c8948754d21dbc9f517e37ee">here</a></p>]]></description>
    <pubDate>Fri, 23 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://hyegar.com/2016/12/23/async-promises-node/index.html</guid>
    <dc:creator>Edgar Aroutiounian</dc:creator>
</item>
<item>
    <title>Using JavaScriptCore with examples</title>
    <link>http://hyegar.com/2016/11/03/using-javascriptcore/index.html</link>
    <description><![CDATA[<h2 id="motivation">Motivation</h2>
<p>I like mixing languages and I especially like <code>OCaml</code>, <code>JavaScript</code>. Lately I’ve been writing <code>OCaml</code> bindings to <code>JavaScriptCore</code>, JSC is what underpins Safari both iOS and desktop variants, and ReactNative. When you’re writing bindings, you kinda need to know the <code>C/C++</code> library that you’re binding to.</p>
<h2 id="example">Example</h2>
<p>We’re going to provide a pretty meaty example, we’ll make a custom object in C++ code, then we’ll use it from a <code>JavaScript</code> script. Imagine we want to expose a <code>File</code> like object, JS the language itself has no notion of a File, so it will need support from the C/C++ level; you can imagine this as the objects that say <code>[native code]</code>.</p>
<p>Here’s the code, afterwards is a detailed breakdown (The <code>R</code> C++ feature confuses the syntax highlighter)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;string&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span>

<span class="bu">std::</span>string getcwd_string(<span class="dt">void</span>)
{
   <span class="dt">char</span> buff[PATH_MAX];
   getcwd(buff, PATH_MAX);
   <span class="bu">std::</span>string cwd(buff);
   <span class="cf">return</span> cwd;
}

<span class="at">const</span> <span class="dt">char</span>*
jsvalue_to_utf8_string(JSGlobalContextRef ctx, JSValueRef v)
{
  JSStringRef valueAsString = JSValueToStringCopy(ctx, v, NULL);
  <span class="dt">size_t</span> jsSize = JSStringGetMaximumUTF8CStringSize(valueAsString);
  <span class="dt">char</span>* jsBuffer = (<span class="dt">char</span>*)malloc(jsSize);
  JSStringGetUTF8CString(valueAsString, jsBuffer, jsSize);
  JSStringRelease(valueAsString);
  <span class="cf">return</span> jsBuffer;
}

<span class="dt">void</span> run_example(<span class="dt">void</span>)
{
  JSClassDefinition definition = kJSClassDefinitionEmpty;
  definition.className = <span class="st">&quot;File&quot;</span>;
  definition.callAsConstructor = [](<span class="kw">auto</span> ctx,
				    <span class="kw">auto</span> object,
				    <span class="kw">auto</span> argumentCount,
				    <span class="kw">auto</span> arguments[],
				    <span class="kw">auto</span> *exception) -&gt; JSObjectRef {
    <span class="kw">auto</span> file_name =
    JSValueMakeString(ctx, JSStringCreateWithUTF8CString(getcwd_string().c_str()));
    <span class="kw">auto</span> prop_name = JSStringCreateWithUTF8CString(<span class="st">&quot;cwdName&quot;</span>);
    <span class="kw">auto</span> example_obj = JSObjectMake(ctx, <span class="kw">nullptr</span>, <span class="kw">nullptr</span>);

    JSObjectSetProperty(ctx,
			example_obj,
			prop_name,
			file_name,
			kJSPropertyAttributeNone,
			<span class="kw">nullptr</span>);
    <span class="cf">return</span> example_obj;
  };

  <span class="kw">auto</span> ctx = JSGlobalContextCreate(<span class="kw">nullptr</span>);
  <span class="kw">auto</span> js_example_class = JSClassCreate(&amp;definition);
  <span class="kw">auto</span> example_obj = JSObjectMake(ctx, js_example_class, <span class="kw">nullptr</span>);
  <span class="co">// auto called_result = JSObjectCallAsConstructor(ctx, example_obj, 0, nullptr, nullptr);</span>
  <span class="co">// auto property_check =</span>
  <span class="co">//   JSObjectGetProperty(ctx,</span>
  <span class="co">// 			called_result,</span>
  <span class="co">// 			JSStringCreateWithUTF8CString(&quot;cwdName&quot;),</span>
  <span class="co">// 			nullptr);</span>

  <span class="co">// std::cout &lt;&lt; jsvalue_to_utf8_string(ctx, property_check) &lt;&lt; std::endl;</span>
  <span class="bu">std::</span>string code_to_eval = <span class="st">R&quot;(</span>
<span class="st">const example_code = new File;</span>
<span class="st">example_code.cwdName;</span>
<span class="st">)&quot;;</span>
<span class="st">  JSValueRef exn;</span>

<span class="st">  auto global_object = JSContextGetGlobalObject(ctx);</span>
<span class="st">  JSObjectSetProperty(ctx,</span>
<span class="st">		      global_object,</span>
<span class="st">		      JSStringCreateWithUTF8CString(&quot;File&quot;),</span>
<span class="st">		      example_obj,</span>
<span class="st">		      kJSPropertyAttributeNone,</span>
<span class="st">		      nullptr);</span>

<span class="st">  auto sanity_check =</span>
<span class="st">    JSEvaluateScript(ctx,</span>
<span class="st">		     JSStringCreateWithUTF8CString(code_to_eval.c_str()),</span>
<span class="st">		     nullptr,</span>
<span class="st">		     nullptr,</span>
<span class="st">		     1,</span>
<span class="st">		     &amp;exn);</span>
<span class="st">  if (exn)</span>
<span class="st">    std::cout &lt;&lt; jsvalue_to_utf8_string(ctx, exn) &lt;&lt; std::endl;</span>

<span class="st">  std::cout &lt;&lt; jsvalue_to_utf8_string(ctx, sanity_check) &lt;&lt; std::endl;</span>
<span class="st">}</span>

<span class="st">int main(int argc, char **argv)</span>
<span class="st">{</span>
<span class="st">  run_example();</span>
<span class="st">  return 0;</span>
<span class="st">}</span></code></pre></div>
<p>compile with, should work just fine on Linux as well, but using:</p>
<p><code>libjavascriptcoregtk-4.0</code> instead of the <code>-framework JavaScriptCore</code></p>
<pre class="shell"><code>$ clang++ -framework JavaScriptCore -std=c++14 jsc_examples.cpp -oF </code></pre>
<h2 id="explanations">Explanations</h2>
<p>The real meat of the code starts at <code>run_example</code>. We start by creating a <code>JSClassDefinition</code>, this creates a template that lets us control all the behavior of our custom object. Then we provide an implementation for what code ought to be run when our custom object will created with <code>new</code>, notice using <code>C++14</code>’s nice ability to use <code>auto</code> for the parameter names, also notice that we explicitly have to give back the return type of <code>JSObjectRef</code>, you get a bit spoiled by the <code>OCaml</code> type system. Then we create a <code>JavaScript</code> object, set the property <code>cwdName</code> and return that new object from the constructor call.</p>
<p>Then we need to make a global context, this is like the environment that your JavaScript runs in and we grab the global object out of it, like <code>window</code> in the browser. (The commented out code is if you wanted to call the constructor and get the result directly in code)</p>
<p>We set the class object as a property to the global, aka like doing <code>window.d3 = //d3's code</code>. Then we evaluate a script, some fun trival all your <code>&lt;script&gt;</code> tags actually have a return value, its the last value.</p>
<p>Tada.</p>
<p>FWIW I’m doing the OCaml bindings <a href="https://github.com/fxfactorial/ocaml-javascriptcore">here</a> github stars appreciated :)</p>]]></description>
    <pubDate>Thu, 03 Nov 2016 00:00:00 UT</pubDate>
    <guid>http://hyegar.com/2016/11/03/using-javascriptcore/index.html</guid>
    <dc:creator>Edgar Aroutiounian</dc:creator>
</item>
<item>
    <title>ReactJS, JSX, async/await, babel, webpack and getting it all working</title>
    <link>http://hyegar.com/2016/09/20/webdev-setup/index.html</link>
    <description><![CDATA[<h3 id="stranger-in-a-strange-land">Stranger in a strange land</h3>
<p>I’m not primarily a front-end dev so getting everything setup and configured for web development is particularly frustrating for me and most blog posts, tutorials don’t actually give explanations, just copy-pasting blindly tons of little configs.</p>
<p>Here’s my post that I’m using as reference for me and hopefully for any other non-frontend developer that wants to use the latest and greatest <code>JavaScript</code> like <code>fetch</code>, <code>async</code>, <code>await</code>, <code>React</code>, <code>JSX</code>.</p>
<h3 id="getting-started-compiling-javascript-to-javascript">Getting started, compiling JavaScript to …JavaScript</h3>
<p>Because of fragmentation in implementations of the latest <code>JavaScript</code> features, we’ll use <code>babel</code> to compile our <code>JavaScript</code> using the latest features to <code>JavaScript</code> that will work in <code>Chrome</code>, <code>Firefox</code> and <code>Safari</code>.</p>
<p><code>babel</code> has a concept of <code>plugins</code>. These are like features that you can turn on during the compilation steps and are pretty granular. Often you’ll want a whole bunch of plugins together and that is so common enough that <code>babel</code> has something called <code>presets</code>. You can put that in separate <code>.babelrc</code> file, but I prefer not having so much silly little config files, so you can also put it in your package.json; example:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"> <span class="st">&quot;babel&quot;</span><span class="op">:</span> <span class="op">{</span>
    <span class="st">&quot;presets&quot;</span><span class="op">:</span> [
      <span class="st">&quot;react&quot;</span><span class="op">,</span>
      <span class="st">&quot;es2015&quot;</span><span class="op">,</span>
      <span class="st">&quot;stage-3&quot;</span>
    ]<span class="op">,</span>
    <span class="st">&quot;plugins&quot;</span><span class="op">:</span> [
        <span class="st">&quot;transform-es2015-modules-commonjs&quot;</span><span class="op">,</span>
        <span class="st">&quot;transform-async-to-generator&quot;</span><span class="op">,</span>
        <span class="st">&quot;transform-runtime&quot;</span>
    ]
  <span class="op">}</span></code></pre></div>
<p>These are the ones I’m using to compile <code>JSX</code>, use ES6 modules, and <code>async</code>, <code>await</code>.</p>
<p>So when you invoke <code>babel</code>, it will look at the <code>package.json</code>, see the <code>babel</code> field and turn on those features, so an example invocation is:</p>
<pre class="shell"><code>$ babel lib --out-dir dist</code></pre>
<p>which will compile all the code in the <code>lib</code> directory and output the results in the <code>dist</code> directory. This process is the same for <code>node</code>.</p>
<h3 id="bundling-code">Bundling code</h3>
<p>Now we have our legal <code>JavaScript</code> for today’s browsers/node. We can bundle up everything as a single <code>JavaScript</code> file using <code>webpack</code>. I previously used <code>browserify</code> but like all things web, apparently its not hot anymore. We can invoke it like so:</p>
<pre class="shell"><code>$ webpack --progress --colors dist/homepage.js bundle.js</code></pre>
<p>where <code>bundle.js</code> is the name of the single output file that we’ll get. You can apparently do some kind of config file for webpack, yet another config file, but this is enough for me right now.</p>
<h3 id="actual-codeproject-with-jsx">Actual code/project with JSX</h3>
<p>So let’s say we have these two files, one is <code>homepage.jsx</code> and the other is <code>button.jsx</code>. Note that I use a real example of <code>async</code>, <code>await</code>, for a great explanation see <a href="https://zeit.co/blog/async-and-await">here</a>, for <code>OCaml</code> programmers, <code>await</code> is basically <code>&gt;&gt;=</code> or <code>let%lwt</code>.</p>
<p>This is <code>button.jsx</code></p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="st">&#39;use strict&#39;</span><span class="op">;</span>
<span class="im">import</span> React <span class="im">from</span> <span class="st">&#39;react&#39;</span><span class="op">;</span>

<span class="kw">class</span> Button <span class="kw">extends</span> <span class="va">React</span>.<span class="at">Component</span> <span class="op">{</span>

  async <span class="at">do_request</span>(e) <span class="op">{</span>
    <span class="kw">let</span> query <span class="op">=</span>
	<span class="st">&#39;https://api.bitcoinaverage.com&#39;</span> <span class="op">+</span>
	<span class="st">&#39;/ticker/global/USD&#39;</span><span class="op">;</span>
    <span class="kw">let</span> nonsense <span class="op">=</span> <span class="st">&quot;https://foo.bar&quot;</span><span class="op">;</span>
    <span class="cf">try</span> <span class="op">{</span>
      <span class="kw">let</span> pulled <span class="op">=</span> await <span class="at">fetch</span>(query)<span class="op">;</span>
      <span class="kw">let</span> body <span class="op">=</span> await <span class="va">pulled</span>.<span class="at">json</span>()<span class="op">;</span>
      <span class="va">console</span>.<span class="at">log</span>(body)<span class="op">;</span>

      await <span class="at">fetch</span>(nonsense)<span class="op">;</span>

    <span class="op">}</span> <span class="cf">catch</span> (e) <span class="op">{</span>
      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Exception raised:&quot;</span><span class="op">,</span> e)<span class="op">;</span>
      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Logic continued&#39;</span>)<span class="op">;</span>
    <span class="op">}</span>
  <span class="op">}</span>

  <span class="at">render</span> () <span class="op">{</span>
    <span class="kw">let</span> s <span class="op">=</span> <span class="op">{</span><span class="dt">color</span><span class="op">:</span><span class="st">&#39;red&#39;</span><span class="op">};</span>
    <span class="cf">return</span> (
      <span class="op">&lt;</span>p style<span class="op">={</span>s<span class="op">}</span>
	 onClick<span class="op">={</span><span class="kw">this</span>.<span class="va">do_request</span>.<span class="at">bind</span>(<span class="kw">this</span>)<span class="op">}&gt;</span>
	Click Me
      <span class="op">&lt;</span><span class="ss">/p&gt;</span>
<span class="ss">    </span><span class="sc">)</span><span class="ss">;</span>
<span class="ss">  }</span>
<span class="ss">};</span>
<span class="ss">// Remember to put wrap in {}</span>
<span class="ss">export {Button};</span></code></pre></div>
<p>and <code>homepage.jsx</code></p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="st">&#39;use strict&#39;</span><span class="op">;</span>

<span class="im">import</span> React <span class="im">from</span> <span class="st">&#39;react&#39;</span><span class="op">;</span>
<span class="im">import</span> ReactDOM <span class="im">from</span> <span class="st">&#39;react-dom&#39;</span><span class="op">;</span>
<span class="co">// REMEMBER to do {} since button.jsx doesn&#39;t do</span>
<span class="co">// export default</span>
<span class="im">import</span> <span class="op">{</span>Button<span class="op">}</span> <span class="im">from</span> <span class="st">&#39;./button&#39;</span><span class="op">;</span>

<span class="kw">class</span> Page <span class="kw">extends</span> <span class="va">React</span>.<span class="at">Component</span> <span class="op">{</span>
  <span class="at">render</span> () <span class="op">{</span>
    <span class="cf">return</span> (
      <span class="op">&lt;</span>div<span class="op">&gt;</span>
	Hello World
	<span class="op">&lt;</span>Button/<span class="op">&gt;</span>
      <span class="op">&lt;</span><span class="ss">/div&gt;</span>
<span class="ss">    </span><span class="sc">)</span><span class="ss">;</span>
<span class="ss">  }</span>
<span class="ss">};</span>

<span class="ss">ReactDOM.render</span><span class="sc">(</span><span class="ss">&lt;Page/</span><span class="op">&gt;,</span>
		<span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&#39;cont&#39;</span>))<span class="op">;</span></code></pre></div>
<p>So all this will be compiled correctly and turned into one <code>bundle.js</code> which we can use in this <code>index.html</code></p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span>
<span class="kw">&lt;meta</span><span class="ot"> charset=</span><span class="st">&quot;utf-8&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;body&gt;</span>
  <span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;cont&quot;</span><span class="kw">&gt;&lt;/div&gt;</span>
  <span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;bundle.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;/body&gt;</span></code></pre></div>
<p>and when we click the button we see this in the Chrome dev tools:</p>
<pre><code>Object {24h_avg: 614.98, ask: 613.72, bid: 613.05, last: 613.56, timestamp: &quot;Tue, 20 Sep 2016 20:09:30 -0000&quot;…}
bundle.js:23085 GET https://foo.bar/ net::ERR_NAME_NOT_RESOLVED_callee$ @ bundle.js:23085tryCatch @ bundle.js:23242invoke @ bundle.js:23516prototype.(anonymous function) @ bundle.js:23275step @ bundle.js:23872(anonymous function) @ bundle.js:23883
bundle.js:23095 Exception raised: TypeError: Failed to fetch(…)
bundle.js:23096 Logic continued</code></pre>
<p>Yay, things worked.</p>
<p>See the repo <a href="https://github.com/fxfactorial/react-example-with-async-await-babel">here</a> for the full <code>package.json</code></p>]]></description>
    <pubDate>Tue, 20 Sep 2016 00:00:00 UT</pubDate>
    <guid>http://hyegar.com/2016/09/20/webdev-setup/index.html</guid>
    <dc:creator>Edgar Aroutiounian</dc:creator>
</item>
<item>
    <title>Calling a C function from within a binary on OS X/iOS</title>
    <link>http://hyegar.com/2016/08/31/grabbing-function-location/index.html</link>
    <description><![CDATA[<p><em>If you like this and other posts of mine, then reach out to me at edgar.factorial@gmail.com, I’m looking for remote contract work.</em></p>
<p>Let’s say we have a C binary given to us and there’s a C function in it that we want to call. For example, say we have this code, assume it is called <code>inject_me.c</code>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> test_function(<span class="dt">char</span> *some_word)
{
  <span class="cf">return</span> printf(<span class="st">&quot;Did say: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, some_word);
}

<span class="dt">int</span> main (<span class="dt">int</span> argc, <span class="dt">char</span> **argv)
{
  <span class="cf">return</span> test_function(<span class="st">&quot;Hello World&quot;</span>);
}</code></pre></div>
<p>and we want to call the function <code>test_function</code> by ourselves. To do that we need to find the location of the function in the binary. We can do that by disassembling the binary, I used to use command line tools for that but now I’m using <code>hopper</code>. (Hopper is an AMAZING program). Once we disassemble it, we find the function in memory:</p>
<div class="figure">
<img src="/images/found_test_function.png" />

</div>
<p>Notice that I highlighted the actual location of: <code>0x100000f20</code>. Now we can inject it with this code, assume it is called <code>inject.c</code></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;string.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;mach-o/dyld.h&gt;</span>

<span class="pp">#define SPOT 0x100000f20</span>

<span class="kw">typedef</span> <span class="dt">int</span> pull_it(<span class="dt">char</span> *);

<span class="dt">static</span> pull_it *pulled = NULL;

__attribute__((constructor))
<span class="dt">void</span> example_injection()
{
  <span class="dt">char</span> path[<span class="dv">1024</span>];
  <span class="dt">uint32_t</span> size = <span class="kw">sizeof</span>(path);
  _NSGetExecutablePath(path, &amp;size);
  
  <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; _dyld_image_count(); i++) {
    <span class="cf">if</span> (strcmp(_dyld_get_image_name(i), path) == <span class="dv">0</span>) {
      <span class="dt">intptr_t</span> slide = _dyld_get_image_vmaddr_slide(i);

      pulled = (pull_it*)(<span class="dt">intptr_t</span>)(slide + SPOT);
      printf(<span class="st">&quot;slide: %lu</span><span class="sc">\n</span><span class="st">&quot;</span>, slide);
      pulled(<span class="st">&quot;Please work</span><span class="sc">\n</span><span class="st">&quot;</span>);
    }
  }

  printf(<span class="st">&quot;This ran before the actual program</span><span class="sc">\n</span><span class="st">&quot;</span>);
}</code></pre></div>
<ol style="list-style-type: decimal">
<li><p>The <code>__attribute__((constructor))</code> calls the wrapped function before <code>main</code> goes off.</p></li>
<li><p>The slide is needed because: (I found this on some Apple mailing list and don’t remember from where anymore)</p></li>
</ol>
<pre><code>Q: Can someone enlighten me as to what the virtual memory slide amount
is ? (this parameter is returned by _dyld_get_image_vmaddr_slide for
instance)

A: The shared libraries are prebound to an initial base address but
when the shared library gets loaded dyld can &quot;slide&quot; the library to a
new base address, this is where the virtual memory slide comes from.</code></pre>
<p>Build both with this <code>Makefile</code></p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dt">osx_clang </span><span class="ch">:=</span><span class="st"> </span><span class="ch">$(</span><span class="kw">shell</span><span class="st"> xcrun --sdk macosx --find clang</span><span class="ch">)</span>
<span class="dt">osx_sdk </span><span class="ch">:=</span><span class="st"> </span><span class="ch">$(</span><span class="kw">shell</span><span class="st"> xcrun --sdk macosx --show-sdk-path</span><span class="ch">)</span>
<span class="dt">c_flags </span><span class="ch">:=</span><span class="st"> -std=c11</span>

<span class="dv">inject_me:</span><span class="dt">inject_me.c</span>
	<span class="ch">@${</span><span class="dt">osx_clang</span><span class="ch">}</span><span class="fu"> -isysroot </span><span class="ch">${</span><span class="dt">osx_sdk</span><span class="ch">}</span><span class="fu"> </span><span class="ch">${</span><span class="dt">c_flags</span><span class="ch">}</span><span class="fu"> </span><span class="ch">$&lt;</span><span class="fu"> -o </span><span class="ch">$@</span>

<span class="dv">code_injection:</span><span class="dt">inject_me</span>
	<span class="ch">@${</span><span class="dt">osx_clang</span><span class="ch">}</span><span class="fu"> -isysroot </span><span class="ch">${</span><span class="dt">osx_sdk</span><span class="ch">}</span><span class="fu"> </span><span class="ch">${</span><span class="dt">c_flags</span><span class="ch">}</span><span class="fu"> inject.c -dynamiclib -o </span><span class="ch">$@</span><span class="fu">.dylib</span></code></pre></div>
<p>Now we can invoke it like so:</p>
<pre class="shell"><code>$ make code_injection
$ DYLD_INSERT_LIBRARIES=code_injection.dylib ./inject_me
slide: 125042688
Did say: Please work

This ran before the actual program
Did say: Hello World</code></pre>
<p>Yay, it works. BTW, this works for jailbroken iOS as well.</p>]]></description>
    <pubDate>Wed, 31 Aug 2016 00:00:00 UT</pubDate>
    <guid>http://hyegar.com/2016/08/31/grabbing-function-location/index.html</guid>
    <dc:creator>Edgar Aroutiounian</dc:creator>
</item>
<item>
    <title>Imperatively traverse binary trees in OCaml, print zigzag</title>
    <link>http://hyegar.com/2016/07/18/imperative-traversal-ocaml/index.html</link>
    <description><![CDATA[<p>OCaml tree examples tend to be defined with algebraic data types and tend to be functional examples. Here are two imperative tree traversals, a pre-order and in-order. I’m still trying to work out a nice post-order imperative solution in OCaml so if you have one then please tweet it at me: <span class="citation">@edgararout</span></p>
<p>EDIT: I’ve added a zigzag function procedure as well. This question came up recently at an interview and I messed it up. The point is to print the tree in a zigzag pattern.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> &#39;a node = {<span class="kw">mutable</span> data: &#39;a;
                <span class="kw">mutable</span> left : &#39;a node <span class="dt">option</span>;
                <span class="kw">mutable</span> right: &#39;a node <span class="dt">option</span>; }

<span class="kw">let</span> new_node data = {data; left = <span class="dt">None</span>; right = <span class="dt">None</span>;}

<span class="kw">let</span> insert tree new_data =
  <span class="kw">let</span> <span class="kw">module</span> Wrapper = <span class="kw">struct</span> <span class="kw">exception</span> Stop_loop <span class="kw">end</span> <span class="kw">in</span>
  <span class="kw">let</span> iter = <span class="dt">ref</span> tree <span class="kw">in</span>
  <span class="kw">try</span>
    <span class="kw">while</span> <span class="kw">true</span> <span class="kw">do</span>
      <span class="kw">if</span> new_data &lt; !iter.data
      <span class="kw">then</span> <span class="kw">match</span> !iter.left <span class="kw">with</span>
        | <span class="dt">None</span> -&gt;
          !iter.left &lt;- <span class="dt">Some</span> (new_node new_data);
          <span class="dt">raise</span> Wrapper.Stop_loop
        | <span class="dt">Some</span> left_tree -&gt; iter := left_tree
      <span class="kw">else</span> <span class="kw">if</span> new_data &gt; !iter.data
      <span class="kw">then</span> <span class="kw">match</span> !iter.right <span class="kw">with</span>
        | <span class="dt">None</span> -&gt;
          !iter.right &lt;- <span class="dt">Some</span> (new_node new_data);
          <span class="dt">raise</span> Wrapper.Stop_loop
        | <span class="dt">Some</span> right_tree -&gt; iter := right_tree
    <span class="kw">done</span>
  <span class="kw">with</span> Wrapper.Stop_loop -&gt; ()

<span class="kw">let</span> pre_order_traversal tree =
  <span class="kw">let</span> s = <span class="dt">Stack</span>.create () <span class="kw">in</span>
  <span class="dt">Stack</span>.push tree s;
  <span class="kw">while</span> <span class="dt">not</span> (<span class="dt">Stack</span>.is_empty s) <span class="kw">do</span>
    <span class="kw">let</span> iter_node = <span class="dt">Stack</span>.pop s <span class="kw">in</span>

    <span class="dt">Printf</span>.sprintf <span class="st">&quot;%s &quot;</span> iter_node.data
    |&gt; <span class="dt">print_string</span>;

    (<span class="kw">match</span> iter_node.right <span class="kw">with</span>
       <span class="dt">None</span> -&gt; ()
     | <span class="dt">Some</span> right -&gt; <span class="dt">Stack</span>.push right s);

    (<span class="kw">match</span> iter_node.left <span class="kw">with</span>
       <span class="dt">None</span> -&gt; ()
     | <span class="dt">Some</span> left -&gt; <span class="dt">Stack</span>.push left s)
  <span class="kw">done</span>

<span class="kw">let</span> in_order_traversal tree =
  <span class="kw">let</span> <span class="kw">module</span> W = <span class="kw">struct</span> <span class="kw">exception</span> Stop_loop <span class="kw">end</span> <span class="kw">in</span>
  <span class="kw">let</span> visited_stack = <span class="dt">Stack</span>.create () <span class="kw">in</span>
  <span class="kw">let</span> iter_node = <span class="dt">ref</span> (<span class="dt">Some</span> tree) <span class="kw">in</span>
  <span class="kw">try</span> <span class="kw">while</span> <span class="kw">true</span> <span class="kw">do</span>
      <span class="co">(* Inner loop, we keep trying to go left *)</span>
      (<span class="kw">try</span> <span class="kw">while</span> <span class="kw">true</span> <span class="kw">do</span>
           <span class="kw">match</span> !iter_node <span class="kw">with</span>
           | <span class="dt">None</span> -&gt; <span class="dt">raise</span> W.Stop_loop
           | <span class="dt">Some</span> left -&gt;
             <span class="dt">Stack</span>.push left visited_stack;
             iter_node := left.left
         <span class="kw">done</span>;
       <span class="kw">with</span> W.Stop_loop -&gt; ());

      <span class="co">(* If we have no more to process in the stack, then we&#39;re</span>
<span class="co">         done *)</span>
      <span class="kw">if</span> <span class="dt">Stack</span>.length visited_stack = <span class="dv">0</span>
      <span class="kw">then</span> <span class="dt">raise</span> W.Stop_loop
      <span class="kw">else</span>
        <span class="co">(* Here we&#39;re forced to start moving rightward *)</span>
        <span class="kw">let</span> temp = <span class="dt">Stack</span>.pop visited_stack <span class="kw">in</span>
        <span class="dt">Printf</span>.sprintf <span class="st">&quot;%s &quot;</span> temp.data |&gt; <span class="dt">print_string</span>;
        iter_node := temp.right
    <span class="kw">done</span>
  <span class="kw">with</span> W.Stop_loop -&gt; ()

<span class="kw">let</span> print_spiral root =
  <span class="kw">let</span> (current, next) = <span class="dt">Stack</span>.(<span class="dt">ref</span> (create ()), <span class="dt">ref</span> (create ())) <span class="kw">in</span>
  <span class="kw">let</span> left_to_right = <span class="dt">ref</span> <span class="kw">true</span> <span class="kw">in</span>

  <span class="kw">let</span> swap a b = <span class="kw">let</span> (a_, b_) = !a, !b <span class="kw">in</span> a := b_; b := a_ <span class="kw">in</span>

  <span class="dt">Stack</span>.push root !current;

  <span class="kw">while</span> <span class="dt">not</span> (<span class="dt">Stack</span>.is_empty !current) <span class="kw">do</span>
    <span class="kw">let</span> r = <span class="dt">Stack</span>.top !current <span class="kw">in</span>
    <span class="dt">Stack</span>.pop !current |&gt; <span class="dt">ignore</span>;
    <span class="dt">Printf</span>.sprintf <span class="st">&quot;%s &quot;</span> r.data |&gt; <span class="dt">print_string</span>;
    <span class="kw">if</span> !left_to_right <span class="kw">then</span>
      <span class="kw">begin</span>
        (<span class="kw">match</span> r.left <span class="kw">with</span> <span class="dt">None</span> -&gt; () | <span class="dt">Some</span> l -&gt; <span class="dt">Stack</span>.push l !next);
        (<span class="kw">match</span> r.right <span class="kw">with</span> <span class="dt">None</span> -&gt; () | <span class="dt">Some</span> r -&gt; <span class="dt">Stack</span>.push r !next)
      <span class="kw">end</span>
    <span class="kw">else</span> <span class="kw">begin</span>
      (<span class="kw">match</span> r.right <span class="kw">with</span> <span class="dt">None</span> -&gt; () | <span class="dt">Some</span> r -&gt; <span class="dt">Stack</span>.push r !next);
      (<span class="kw">match</span> r.left <span class="kw">with</span> <span class="dt">None</span> -&gt; () | <span class="dt">Some</span> l -&gt; <span class="dt">Stack</span>.push l !next)
    <span class="kw">end</span>;

    <span class="kw">if</span> <span class="dt">Stack</span>.length !current = <span class="dv">0</span>
    <span class="kw">then</span> (left_to_right := <span class="dt">not</span> !left_to_right; swap current next)

  <span class="kw">done</span>

<span class="kw">let</span> () =
  <span class="kw">let</span> root = new_node <span class="st">&quot;F&quot;</span> <span class="kw">in</span>

  [<span class="st">&quot;B&quot;</span>;<span class="st">&quot;G&quot;</span>;<span class="st">&quot;A&quot;</span>;<span class="st">&quot;D&quot;</span>;<span class="st">&quot;I&quot;</span>;<span class="st">&quot;C&quot;</span>;<span class="st">&quot;E&quot;</span>;<span class="st">&quot;H&quot;</span>] |&gt; <span class="dt">List</span>.iter (insert root);

  pre_order_traversal root;
  <span class="dt">print_newline</span> ();
  in_order_traversal root
  <span class="dt">print_newline</span> ();
  print_spiral root</code></pre></div>]]></description>
    <pubDate>Mon, 18 Jul 2016 00:00:00 UT</pubDate>
    <guid>http://hyegar.com/2016/07/18/imperative-traversal-ocaml/index.html</guid>
    <dc:creator>Edgar Aroutiounian</dc:creator>
</item>
<item>
    <title>Intermediate js_of_ocaml</title>
    <link>http://hyegar.com/2016/07/17/js-of-ocaml-usage/index.html</link>
    <description><![CDATA[<p>This post is mainly aimed at intermediate level users of <code>js_of_ocaml</code>, the <code>OCaml</code> to <code>JavaScript</code> compiler and at improving the sad state of documentation for <code>js_of_ocaml</code>. (Plus I’m interviewing for jobs, hire me!, and wanted to use both OCaml, JavaScript while preparing for interviews)</p>
<h1 id="ocaml-typing-of-javascript-uses-ppx">OCaml typing of JavaScript (Uses PPX)</h1>
<p>Say we want to express some algorithms in OCaml but using JavaScript as the runtime execution language/environment. Let’s start with our main data structure, a tree node.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">TreeNode</span>(value) <span class="op">{</span>
  <span class="kw">this</span>.<span class="at">value</span> <span class="op">=</span> value<span class="op">;</span>
  <span class="kw">this</span>.<span class="at">left</span> <span class="op">=</span> <span class="kw">this</span>.<span class="at">right</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Our OCaml version will be:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">class</span> <span class="kw">type</span> [&#39;data] tree_node = <span class="kw">object</span>
  <span class="kw">method</span> value : &#39;data Js.prop
  <span class="kw">method</span> left : &#39;data tree_node Js.t Js.prop
  <span class="kw">method</span> right : &#39;data tree_node Js.t Js.prop
<span class="kw">end</span></code></pre></div>
<p>Note that there is a small thing about typing the nullability of the left, right fields, I will return to this at the end of the blog post and it was done for convenience.</p>
<p>So explanations:</p>
<ol start="0" style="list-style-type: decimal">
<li>We are creating a <code>class type</code>, this just describes the object, how we describe it is key.</li>
<li>The <code>'data</code> is a type variable and lets us use any kind of type for the value in this node.</li>
<li>OCaml objects only expose methods to the outside world, so properties need <code>Js.prop</code>, this lets us read and write to this field. We can control it to be read only by instead using <code>Js.readonly_prop</code> or even write only with <code>Js.writeonly_prop</code>.</li>
<li>Methods <code>left</code>, <code>right</code> are also properties. Read the signature from right to left, aka <code>left</code> is a JavaScript read or write property which has a JavaScript object typed as <code>tree_node</code> and parameterized with the <code>'data</code> type variable. Aka tree_nodes of <code>string</code> or <code>int</code> or whatever the type of <code>'data</code> is.</li>
</ol>
<p>Now we need to provide a way to make this object.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> __hidden__ =
  Js.Unsafe.pure_js_expr <span class="st">&quot;function TreeNode(value) {</span><span class="ch">\</span>
<span class="st">                          this.value = value; </span><span class="ch">\</span>
<span class="st">                          this.left = this.right = null;}&quot;</span></code></pre></div>
<p>This is the JavaScript we’ll be using, essentially. Do note that the field names match up, this is important. Now we provide a constructor function:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> node : (&#39;data -&gt; &#39;data tree_node Js.t) Js.constr = __hidden__</code></pre></div>
<p>This <code>node</code> constructor says that its a special JavaScript constructor that will invoke <code>__hidden__</code> with <code>new</code> and such that it expects one argument. An example is:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> root = <span class="kw">new</span>%js node <span class="st">&quot;Hello&quot;</span></code></pre></div>
<p>We can also make specialized constructors,</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> node_from_int : (<span class="dt">int</span> -&gt; <span class="dt">int</span> tree_node Js.t) Js.constr = __hidden__</code></pre></div>
<p>and a simple usage:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> () =
  <span class="kw">let</span> root = <span class="kw">new</span>%js node <span class="st">&quot;Hello&quot;</span> <span class="kw">in</span>
  root##.left := <span class="kw">new</span>%js node <span class="st">&quot;Left side&quot;</span>;
  root##.left##.left := <span class="kw">new</span>%js node <span class="st">&quot;Grand Kid&quot;</span>;

  <span class="co">(* Note that this just prints the raw object representation of the</span>
<span class="co">  field value *)</span>
  Firebug.console##log root##.left##.left##.value;

  <span class="co">(* This shows the value as expected *)</span>
  <span class="dt">print_endline</span> root##.left##.left##.value</code></pre></div>
<p>You can compile and run it on node with: (Assuming file name is <code>trees_in_js.ml</code>)</p>
<pre class="shell"><code>$ ocamlfind ocamlc -package js_of_ocaml.ppx -linkpkg trees_in_js.ml
$ js_of_ocaml a.out -o T.js
$ node T.js</code></pre>
<p>And you should get something like the following printed out:</p>
<pre class="shell"><code>h { t: 0, c: &#39;Grand Kid&#39;, l: 9 }
Grand Kid</code></pre>
<h1 id="depth-first-search-level-order-traversal-complete-examples">Depth First Search, Level order traversal complete examples</h1>
<p>Now here’s an example of a preorder depth first search and level order traversal.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">class</span> <span class="kw">type</span> [&#39;data] tree_node = <span class="kw">object</span>
  <span class="kw">method</span> value : &#39;data Js.prop
  <span class="kw">method</span> left : &#39;data tree_node Js.t Js.prop
  <span class="kw">method</span> right : &#39;data tree_node Js.t Js.prop
<span class="kw">end</span>

<span class="kw">let</span> node : (&#39;data -&gt; &#39;data tree_node Js.t) Js.constr = __hidden__

<span class="kw">let</span> depth_first_search starting_node =
  <span class="kw">let</span> stack = <span class="dt">Stack</span>.create () <span class="kw">in</span>
  <span class="dt">Stack</span>.push starting_node stack;
  <span class="kw">while</span> <span class="dt">not</span> (<span class="dt">Stack</span>.is_empty stack) <span class="kw">do</span>
    <span class="kw">let</span> iter_node = <span class="dt">Stack</span>.pop stack <span class="kw">in</span>

    <span class="dt">Printf</span>.sprintf <span class="st">&quot;%s &quot;</span> iter_node##.value
    |&gt; <span class="dt">print_string</span>;

    <span class="kw">if</span> Js.Opt.return iter_node##.right |&gt; Js.Opt.test
    <span class="kw">then</span> <span class="dt">Stack</span>.push iter_node##.right stack;

    <span class="kw">if</span> Js.Opt.return iter_node##.left |&gt; Js.Opt.test
    <span class="kw">then</span> <span class="dt">Stack</span>.push iter_node##.left stack

  <span class="kw">done</span>

<span class="kw">let</span> level_order starting_node =
  <span class="kw">let</span> q = <span class="dt">Queue</span>.create () <span class="kw">in</span>
  <span class="dt">Queue</span>.add starting_node q;

  <span class="kw">while</span> <span class="dt">not</span> (<span class="dt">Queue</span>.is_empty q) <span class="kw">do</span>
    <span class="kw">let</span> pop = <span class="dt">Queue</span>.pop q <span class="kw">in</span>
    <span class="dt">Printf</span>.sprintf <span class="st">&quot;%s &quot;</span> pop##.value
    |&gt; <span class="dt">print_string</span>;

    <span class="kw">if</span> Js.Opt.(return pop##.left |&gt; test)
    <span class="kw">then</span> <span class="dt">Queue</span>.push pop##.left q;

    <span class="kw">if</span> Js.Opt.(return pop##.right |&gt; test)
    <span class="kw">then</span> <span class="dt">Queue</span>.push pop##.right q

  <span class="kw">done</span>

<span class="kw">let</span> () =
  <span class="kw">let</span> root = <span class="kw">new</span>%js node <span class="st">&quot;F&quot;</span> <span class="kw">in</span>
  root##.left := <span class="kw">new</span>%js node <span class="st">&quot;B&quot;</span>;
  root##.right := <span class="kw">new</span>%js node <span class="st">&quot;G&quot;</span>;
  root##.right##.right := <span class="kw">new</span>%js node <span class="st">&quot;I&quot;</span>;
  root##.left##.left := <span class="kw">new</span>%js node <span class="st">&quot;A&quot;</span>;
  root##.left##.right := <span class="kw">new</span>%js node <span class="st">&quot;D&quot;</span>;
  root##.left##.right##.left := <span class="kw">new</span>%js node <span class="st">&quot;C&quot;</span>;
  root##.left##.right##.right := <span class="kw">new</span>%js node <span class="st">&quot;E&quot;</span>;
  root##.right##.right##.left := <span class="kw">new</span>%js node <span class="st">&quot;H&quot;</span>;

  depth_first_search root |&gt; <span class="dt">print_newline</span>;
  level_order root |&gt; <span class="dt">print_newline</span></code></pre></div>
<p>and compile it just like given earlier in the blog post. Shameless plug, you can also turn it into an executable with a feature I added to the <code>js_of_ocaml</code> compiler,</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">$ ocamlfind ocamlc -package js_of_ocaml.ppx -linkpkg trees_in_js.ml
$ js_of_ocaml --custom-header=&#39;#!/usr/bin/env node&#39; a.out -o T.js
$ chmod +x T.js
$ /T.js</code></pre></div>
<p>Yay, we used the resources of two programming languages standard libaries in one program!</p>
<p>Now we can return to why the typing of the <code>class type</code> matters. The fully correct typing of <code>tree_node</code> is:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">class</span> <span class="kw">type</span> [&#39;data] tree_node = <span class="kw">object</span>
  <span class="kw">method</span> value : &#39;data Js.prop
  <span class="kw">method</span> left : &#39;data tree_node Js.t Js.Opt.t Js.prop
  <span class="kw">method</span> right : &#39;data tree_node Js.t Js.Opt.t Js.prop
<span class="kw">end</span></code></pre></div>
<p>Notice the addition of <code>Js.Opt.t</code>. Since the <code>left</code>, <code>right</code> are nullable, we should capture that in the OCaml API, this however does force us to use <code>Js.Opt</code> and so we’d have to do things like:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">root##.left := <span class="kw">new</span>%js node <span class="st">&quot;Left side&quot;</span> |&gt; Js.Opt.return;</code></pre></div>
<p>When trying to set the field, etc. But since we didn’t expose that nullability of the field in the type signature, the <code>depth_first_search</code> code needs to check if the field is indeed <code>null</code>, which would have been otherwise forced by the type system had we used <code>Js.Opt</code>, aka:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">if</span> Js.Opt.return iter_node##.right |&gt; Js.Opt.test
<span class="kw">then</span> <span class="dt">Stack</span>.push iter_node##.right stack;</code></pre></div>
<p>These are tradeoffs that you can make in your own usage.</p>
<p>I hope this makes it easier for you to use OCaml, JavaScript together.</p>]]></description>
    <pubDate>Sun, 17 Jul 2016 00:00:00 UT</pubDate>
    <guid>http://hyegar.com/2016/07/17/js-of-ocaml-usage/index.html</guid>
    <dc:creator>Edgar Aroutiounian</dc:creator>
</item>
<item>
    <title>Using system threads with Lwt</title>
    <link>http://hyegar.com/2016/05/21/using-lwt-preemptive/index.html</link>
    <description><![CDATA[<p>This blog post shows you how to use real system threads in OCaml by using <code>Lwt</code>, <code>Lwt_preemptive</code>.</p>
<h1 id="note">!!Note!!</h1>
<p>While this shows system threads being used, only one is will actually be running at any given point in time (Think this akin to Python’s single threadedness, still useful to use threads if bottleneck are IO)</p>
<h1 id="common-complaint-about-multicore">Common complaint about multicore</h1>
<p>A common complaint about OCaml is the lack of true parallelism, about the single threadedness of the runtime. This is true but its not like <code>OCaml</code> programmers don’t have solutions some solutions. Here’s an easy example that you can instantly use in your coding.</p>
<h1 id="setup">Setup</h1>
<p>First we will need some way to verify that our system threads are actually working, we’ll use some math equation to purposefully cause CPU load. Here’s the <code>Sieve Of Eratosthenes</code> Algorithm that I copied from <a href="http://www.scriptol.com/programming/sieve.php#ocaml">here</a>.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">open</span> <span class="dt">List</span>

<span class="kw">type</span> integer = Int <span class="kw">of</span> <span class="dt">int</span>
<span class="kw">let</span> number_two = Int(<span class="dv">2</span>)
<span class="kw">let</span> number_zero = Int(<span class="dv">0</span>)
<span class="kw">let</span> is_less_than_two (Int n) = n &lt; <span class="dv">2</span>
<span class="kw">let</span> <span class="dt">incr</span> (Int n) = Int(n + <span class="dv">1</span>)
<span class="kw">let</span> <span class="dt">decr</span> (Int n) = Int(n - <span class="dv">1</span>)
<span class="kw">let</span> is_number_zero (Int n) = n = <span class="dv">0</span>

<span class="kw">let</span> iota n =
  <span class="kw">let</span> <span class="kw">rec</span> loop curr counter =
    <span class="kw">if</span> is_less_than_two counter <span class="kw">then</span> []
    <span class="kw">else</span> curr::(loop (<span class="dt">incr</span> curr) (<span class="dt">decr</span> counter))
  <span class="kw">in</span>
  loop number_two n

<span class="kw">let</span> sieve lst =
  <span class="kw">let</span> <span class="kw">rec</span> choose_pivot = <span class="kw">function</span>
    | [] -&gt; []
    | car::cdr <span class="kw">when</span> is_number_zero car -&gt;
      car::(choose_pivot cdr)
    | car::cdr -&gt;
      car::(choose_pivot (do_sieve car (<span class="dt">decr</span> car) cdr))

  <span class="kw">and</span> do_sieve step current lst =
    <span class="kw">match</span> lst <span class="kw">with</span>
    | [] -&gt; []
    | car::cdr -&gt;
      <span class="kw">if</span> is_number_zero current
      <span class="kw">then</span> number_zero::(do_sieve step (<span class="dt">decr</span> step) cdr)
      <span class="kw">else</span> car::(do_sieve step (<span class="dt">decr</span> current) cdr)
  <span class="kw">in</span>
  choose_pivot lst

<span class="kw">let</span> is_prime n =
  <span class="kw">match</span> rev (sieve (iota n)) <span class="kw">with</span>
    x::_ -&gt; <span class="dt">not</span> (is_number_zero x)</code></pre></div>
<p>Now our <code>Lwt</code>, <code>Lwt_preemptive</code> code:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">open</span> Lwt.Infix

<span class="kw">let</span> do_example port =
  <span class="kw">let</span> address = Unix.(ADDR_INET (inet_addr_loopback, port)) <span class="kw">in</span>
  Lwt_io.establish_server address (<span class="kw">fun</span> (tcp_in, tcp_out) -&gt;
      () |&gt; Lwt_preemptive.detach (<span class="kw">fun</span> () -&gt;
          <span class="kw">while</span> <span class="kw">true</span> <span class="kw">do</span>
            <span class="dt">ignore</span> (is_prime (Int port))
          <span class="kw">done</span>
        )
      |&gt; Lwt.ignore_result
    )
  |&gt; <span class="dt">ignore</span> |&gt; Lwt.return

<span class="kw">let</span> () =
  <span class="kw">let</span> <span class="kw">rec</span> forever () = <span class="dt">fst</span> (Lwt.wait ()) &gt;&gt;= forever <span class="kw">in</span>
  Lwt_preemptive.init <span class="dv">5</span> <span class="dv">10</span> <span class="dt">ignore</span>;
  ([<span class="dv">2000</span>; <span class="dv">2001</span>; <span class="dv">2002</span>; <span class="dv">2003</span>; <span class="dv">2004</span>]
   |&gt; Lwt_list.iter_p do_example &gt;&gt;= forever)
  |&gt; Lwt_main.run</code></pre></div>
<p>The code that runs inside the callback to <code>Lwt_io.establish_server</code> uses <code>Lwt_preemptive.detach</code>, this creates a new system thread whenever there is something that connects on ports <code>[2000; 2001; 2002; 2003; 2004]</code>. You don’t have to call <code>Lwt_preemptive.init</code> since detach will do it anyway, but I am doing it to ensure that at least 5 threads are made with 10 being the max.</p>
<p>We compile it with:</p>
<pre class="shell"><code>$ ocamlfind ocamlopt -thread -package lwt.unix,lwt.preemptive test_case.ml -linkpkg -o TEST_CASE</code></pre>
<p>And we test it by starting up <code>./TEST_CASE</code>, opening <code>htop</code> and finding <code>TEST_CASE</code> (hit <code>t</code> in htop to see a tree based process view) and running <code>socat STDIN TCP:localhost:&lt;some_port&gt;</code>, where <code>&lt;some_port&gt;</code> is a number in our list of ports (remember <code>[2000; 2001; 2002; 2003; 2004]</code>).</p>
<p>Thus we see in <code>htop</code> the CPU % utilization move for each of the threads of <code>TEST_CASE</code>.</p>
<p>Success! Real system threads.</p>]]></description>
    <pubDate>Sat, 21 May 2016 00:00:00 UT</pubDate>
    <guid>http://hyegar.com/2016/05/21/using-lwt-preemptive/index.html</guid>
    <dc:creator>Edgar Aroutiounian</dc:creator>
</item>
<item>
    <title>Simple timeout usage</title>
    <link>http://hyegar.com/2016/03/22/simple-timeouts/index.html</link>
    <description><![CDATA[<p>I wanted to use a timeout in OCaml for some shell coding but I didn’t want to introduce a big dependency on <code>Lwt</code>. After some googling I found <a href="https://www.reddit.com/r/ocaml/comments/3qapbv/question_about_writing_a_timeout_function_and_the/">this</a></p>
<p>Here’s my take on the timeout function, basically its the same but I push everything into the timeout function itself and use labeled args along a callback for when the timeout goes off.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> timeout ?(on_timeout = <span class="kw">fun</span> () -&gt; ()) ~arg ~timeout ~default_value f =
  <span class="kw">let</span> <span class="kw">module</span> Wrapper = <span class="kw">struct</span> <span class="kw">exception</span> Timeout <span class="kw">end</span> <span class="kw">in</span>
  <span class="kw">let</span> sigalrm_handler = <span class="dt">Sys</span>.Signal_handle (<span class="kw">fun</span> _ -&gt; <span class="dt">raise</span> Wrapper.Timeout) <span class="kw">in</span>
  <span class="kw">let</span> old_behavior = <span class="dt">Sys</span>.signal <span class="dt">Sys</span>.sigalrm sigalrm_handler <span class="kw">in</span>
  <span class="kw">let</span> reset_sigalrm () = <span class="dt">Sys</span>.set_signal <span class="dt">Sys</span>.sigalrm old_behavior <span class="kw">in</span>
  <span class="dt">ignore</span> (Unix.alarm timeout);
  <span class="kw">try</span>
    <span class="kw">let</span> res = f arg <span class="kw">in</span>
    reset_sigalrm ();
    res
  <span class="kw">with</span> exc -&gt;
    reset_sigalrm ();
    <span class="kw">if</span> exc = Wrapper.Timeout
    <span class="kw">then</span> (on_timeout (); default_value)
    <span class="kw">else</span> <span class="dt">raise</span> exc</code></pre></div>
<p>and you can can use it like so:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Sys</span>.command
|&gt; timeout 
   ~arg:<span class="st">&quot;sleep 3&quot;</span> 
   ~timeout:<span class="dv">2</span> 
   ~default_value:(<span class="dv">-1</span>) 
   ~on_timeout:(<span class="kw">fun</span> () -&gt; <span class="dt">print_endline</span> <span class="st">&quot;func timed out&quot;</span>)</code></pre></div>
<p>You might notice that your wrapped function only gets one arg, so how can we use this timeout wrapper on functions that take more than one argument? By currying and using a dummy arg of unit.</p>
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> () =
  <span class="kw">let</span> partialed first second third () = first + second + third <span class="kw">in</span>
  timeout ~arg:() ~timeout:<span class="dv">4</span> ~default_value:(<span class="dv">-1</span>) (partialed <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)
  |&gt; <span class="dt">ignore</span></code></pre></div>
<p>I’ve added this to my <code>podge</code> library found <a href="http://github.com/fxfactorial/podge">here</a>, a collection of useful utility functions.</p>]]></description>
    <pubDate>Tue, 22 Mar 2016 00:00:00 UT</pubDate>
    <guid>http://hyegar.com/2016/03/22/simple-timeouts/index.html</guid>
    <dc:creator>Edgar Aroutiounian</dc:creator>
</item>
<item>
    <title>Building xen-arm-builder from source</title>
    <link>http://hyegar.com/2016/03/15/building-xen-arm-from-source/index.html</link>
    <description><![CDATA[<p>I’m in Morocco for the first <a href="http://marrakech2016.mirage.io/">mirageos</a> hackathon. One of the things I’ve done here is build <a href="https://github.com/mirage/xen-arm-builder">xen-arm-builder</a> from source and it was a big challenge. Here’s my general notes and pointers to help you get over this hump. I assume you know what mirageos/xen are.</p>
<p>Much MUCH thanks to <a href="http://roscidus.com/blog/">Thomas Leonard</a> and <a href="http://somerandomidiot.com/">Mindy Preston</a> for lending me a cubieboard2 and helping me with all the debugging, compiling issues; wouldn’t have been able to do it without them.</p>
<h1 id="machine-setup">Machine Setup</h1>
<p>I did this on Ubuntu 15 and was deploying to a <a href="http://cubieboard.org/2013/06/19/cubieboard2-is-here/">cubieboard2</a>.</p>
<h1 id="example-workflow">Example Workflow</h1>
<p>Assuming that you are connecting the cubieboard2 to your laptop over a serial connection then you can get a shell on the machine with</p>
<pre class="shell"><code>$ screen -h 10000 /dev/ttyUSB0 115200</code></pre>
<p>Then say you are using <a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a>, here’s an example flow.</p>
<pre class="shell"><code>$ git clone https://github.com/mirage/mirage-skeleton
$ cd mirage-skeleton
$ make configure MODE=xen
$ cd console
$ make
$ sudo xl create console.xe</code></pre>
<p>Yay Unikernel on Cubieboard2!</p>
<h1 id="troublesome-issues">Troublesome issues</h1>
<p>I had many, many issues in building the code from source, here are some troubleshooting steps that might help you as well.</p>
<ol start="0" style="list-style-type: decimal">
<li>Be sure to have fast internet because building from source including making a clone of the Linux source, ouch.</li>
<li><code>OPAMVERBOSE=1 opam &lt;anything&gt;</code> is incredibly useful.</li>
<li>Ubuntu 15 will install a <code>gcc-5.0</code> version of the cross-compiler, be sure to do <code>make build CC=arm-linux-gnueabihf-gcc-4.8</code> instead of a plain <code>make build</code>.</li>
<li>Be sure to <strong>not</strong> use the <code>4.02.0</code> compiler, the cubieboard2 is super slow and that OCaml compiler had a performance bug, use the <code>4.02.3</code> compiler instead.</li>
<li>Check <code>top</code> to see some kind of xp binary, it eats the CPU and that really slows down compilation, best to kill them.</li>
<li>Do make sure that the time on the machine is correct, otherwise you’ll have weird hanging by opam which will seem like its building but actually its just stuck on a timing issue, aka be sure to do: <code>sudo ntpdate uk.pool.ntp.org</code> before doing anything with mirage/opam/aptitude.</li>
<li>If you get odd errors like:</li>
</ol>
<pre class="shell"><code>Parsing config from console.xl
xc: error: panic: xc_dom_core.c:185: failed to open file: No such file or directory: Internal error
libxl: error: libxl_dom.c:377:libxl__build_pv: xc_dom_kernel_file failed: No such file or directory
libxl: error: libxl_create.c:1022:domcreate_rebuild_done: cannot
(re-)build domain: -3</code></pre>
<p>Then check that the libraries are correctly set in <code>/usr/lib</code>, check with</p>
<pre class="shell"><code>$ sudo strace -e open xl create console.xl</code></pre>
<p>and either <code>cp</code> or <code>ln</code> them correctly.</p>
<ol start="7" style="list-style-type: decimal">
<li>I recommend just installing all the <code>depopts</code> of all the mirage projects, there are some bugs in mirage opam files that don’t install other needed packages.</li>
</ol>]]></description>
    <pubDate>Tue, 15 Mar 2016 00:00:00 UT</pubDate>
    <guid>http://hyegar.com/2016/03/15/building-xen-arm-from-source/index.html</guid>
    <dc:creator>Edgar Aroutiounian</dc:creator>
</item>

    </channel>
</rss>
